DATA MODELING:
	DATA MODEL PROVIDES VISUAL DIAGRAM AND RELATIONSHIP WITH EACH OTHER.
3 LEVEL DATA MODELS:

1) CONCEPTUAL MODEL
2) LOGICAL MODEL
3) PHYSICAL MODEL

DATABASE ANNOMALY:
1) INSERTION ANOMALY
2) UPDATE ANNOMALY
3) DELETION ANOMOLY


FORWARD ENGINEERING MODEL WITH MYSQL WORKBENCH
REVERSE ENGINEERING MODEL WITH MYSQL WORKBENCH

DATA WHEREHOUSE:
DIMENSIONAL MODEL

WHAT IS DATA WAREHOUSE:
CENTRALIZED DATA REPOSITORY THAT AGGRAGATES,INTEGRATES,STORES AND PROCESS LARGE AMMUNTS OF DATA FROM MULTIPLE SOURCES

DATA WHEREHOUSE:
1) IS SUBJECT ORIENTED
2) IS INTEGRATED
3) IS NON VOLATILE
4) IS TIME VARIENT

DATA WAREHOUSE ARCHITECTURE 

1) DATA SOURCE
2) DATA STAGING
3) DATA WAREHOUSE
4) DATA MARTS


DIMENSIONAL DATA MODELING
BASED IN DIMENSIONS AND FACTS

IT USES SNOWFLAKW SCHEMA

2 TYPES OF DATA 
1) NUMERIC DATA QUANTITATIVE
2) NON NUMERIC QUALITATIVE DATA


DATA MINING:
PROCESS OF FINDING PATTERN IN DATA


DATA MODELING:
THE PROCESS OF DEVELOPING A VISUAL REPRESENTATION OF DATA ELEMENTS AND THEIR RELATIONSIP

ENTITY LAVEL DIAGRAM:
1) CONCEPTUAL DATA MODEL (ENTITY MODEL)
PURPOSE: HIGH LEVEL REPRESENTATION
IT SHOWS BASIC OF LOGICAL DATA MODEL

2) LOGICAL DATA MODEL (IT DEFINES THE PROPERTY AND DEFINE THE FOREIGN KEY AND PRIMARY KEY) MUST INCLUDE ALL ATTRIBUTE AND WHICH COLUMN SERVE AS PRIMARY KEY AND WHICH IS FOREIGN KEY THAT USES FOR RELATIONSHIP

3)PHYSICAL DATA MODEL MUST HAVE DATA TYPE CONSTRATINTS AND ATTRINUTE. PHYSICAL DATA MODEL IS MORE DETAILED THAN LOGICAL MODEL
IN LOGICAL MODEL YOU DONT NEED A DATA TYPE OR CONSTRAINTS OF THE ATTRIBUTE BUT IN PHYSICAL MODEL IT DOES NEEDED.

DATA MODEL:
	1) RELATIONAL DATA MODEL
	2) ENTITY RELATIONSHIP DATA MODEL
	3) HIARARCHICAL DATA MODEL
	4) DIMENSIONAL DATA MODEL
	5) OBJECT ORIENTATED DATA MODEL

1) RELATIONAL DATA BASE:
	PRESENTS THE DATA IN ROW AND COLUMN (TABULAR FORMAT)

	3 TYPE OF RELATIONSHIP
		1) 1-1 RELATIONSHIP
		2) 2-MANY RELATIONSHIP
		3) MANY-MANY RELATIONSHIP
2) ER DATA MODEL:
	1) EACH TABLE IS CONSIDERED SEPARATE ENTITY
	2) ALSO HAS 1-1 1-* AND *-* RELATIONSHIP

3) HIARARCHICAL DATA MODEL:
	ORGANIZE THE DATA LIKE A TREE OR PARENT CHILD RELATIONSHIP

	ONLY PARENT TO CHILD RELATIONSHIP 1-MANY RELATIONSHIP IS POSSIBLE. MULTIPLE CHILD ENTITY ONLY BELINGS TO A SINGLE PARENT ENTITY
	LIKE:
		SALES   => STAFF,CLIENTS
		CLIENTS => ADDRESS,ORDERS
		ORDERS  => PRODUCT,DELIVERY

		ITS LIKE A TREE RELATIONSHIP

4) OOP MODEL:
	BASED ON OOP CONCEPT
	1) EACH ELEMENT REPRESENTS AS CLASS
	2) RELY ON INHERITANCE VERY MUCH
	3) ONE TO MANY , MANY TO MANY, AND ONE TO ONE RELATIONSHIP IS POSSIBLE WITH PROPERTIES
	LIKE THIS

	// base class
	CLASS PERSON:
		ID,
		FULL_NAME
		CONTACT_NUMBER

	// inherited class
	CLASS STAFF EXTENDS PERSON:
		STAFFID
		SALARY

	// inherited class
	CLIENT EXTENDS PERSON:
		CIENTID
		TYPE


STAFF AND CLIENT HAS A "IS A" RELATION WITH PERSON



5) DIMENSIONAL MODEL ( DIMENSIONAL DATA MODEL IS BETTER FOR FAST DATA RETRIVAL AND DATA ANALYSIS)
	DEPENDS ON 2 THINGS:
		1) DIMENSION  
		2) FACTS

	FACT ARE MEASURE MENT GOT FROM THE PROCESS. LIKE A SPECFIC SALES
	SALES TABLE SHOWS HOW MANY SALES OF THE COMPANY


	// fact table
	SALES
		SALES_KEY(PK)
		ITEM_COST // buying price
		ITEM_PRICE // selling price
		
		PRODUCT_KEY (FK)
		TIME_KEY (FK)

	DIMENSION DEFINE THE CONTEXT OF THAT MEASUREMENT (ADDITIONAL INFORMATION)
	LIKE WHEN THE SALES HAPPEN

	SO 

	TIME
		TIME_KEY(pk)
		DATE

	AND

	PRODUCTS
		PRODUCT_KEY(PK)
		PRODUCT_NAME



DATABASE NORMALIZTION:

DATABASE NORMALIZATION IS THE WAY OF DESIGINING THE DATA MODE IN ORDER TO PREVENT ANNOMALY OR INCONSISTANCE
RESOLVE THE ANOMALIES IN THEIR DATABASE TABLES

1) REDUCE DATA DUPLICATION
2) AVOID DATA CHANGES COMPLICATIONS
3) SMPLIFY THE QUERIES


DATABASE TABLE DONT FOLLOW NORMALIZATION

1) INSERTATION ANOMALY
2) UPDATE ANOMALY
3) DELETATION ANOMALY



1ST NORMAL FORM (ATOMACITY RULES):

RULE: THERE MUST BE JUST 1 INSTANCE OF VALUE PER FIELD. THAT MEANS 1 FILED SHOULD NOT CONTAINES MULTIPLE VALUE. THEE SHOULD BE NO DATA REDUNDENCY.
RESOLVE THIS ISSUES BY CREATING OTHER TABLE AND USE THE FOREIGN KEY TO POINT TO THAT DATA

2ND NORMAL FORM:
 1) MUST BE IN FIRST NORMAL FORM
 2) NO PARTIAL DEPENDENCIES

 WHAT IS PARTIAL DEPENDENCIES:
 SUPPOSE THERE IS A DELIVERY TABLE HAS FOLLOWING PROPERTIES



 	DELIVERY:


 		---------------------------
 		ORDER_ID (PK)
 		PRODUCT_ID (PK)			
 		---------------------------
 		ORDER_DATE
 		STATUS



 NOW THERE ARE 2 KEY THAT COMBINED FORM A COMPOSITE KEY. BUT THE ORDER_DATE ONLY DEPENDS ON ORDER_ID NOT PRODUCT ID THATS PARTIAL DEPENDENCIES . YOU MUST MOVE IT TO A  SEPARATE TABLE TO FIX DATE. REMEMBER NON KEY ATTRIBUTES MUST DEPEND ON THE COMPOSITE KEY FULLY NOT PARTIALLY.


 THIRD NORMAL FORM:
 1) FIRST AND SECOND NORMAL FORM
 2) AVOID TRANSITIVE DEPENDENCY

 WHAT IS TRANSITIVE DEPENDENCIES?

 NON KEY ATTRIBUTE IN A TABLE SHOULD ONLY DEPENDS ON PRIMARY KEY NOT ANOTHER NON KEY ATTRIBUTE

 FOR EXAMPLE
 SUPPOSE THERE IS A ADDRESS TABLE

 	ADDRESS:
 		ADD_ID (PK)
 		NAME
 		ZIP
 		LOCATION


 NOW ZIP AND LOCATON ARE RELATED TO EACH OTHER IF YOU CHANGE THE ZIP YOU HAVE TO CHANGE THE LOCATION. SO THEY ARE DEPENDING ON EACH OTHER  THATS TRANSITIVE DEPENDENCIES. TO AVOID THAT THE FIELD SOULD BE TAKEMN OUT AND PUT ON A SEPARATE TABLE

 WHAT WILL BE THE NEW STRUCTURE THEN

 THE NEW STRUCTURE 


 TABLE -> LOCATION
 			ZIP_CODE (PK)
 			LOCATION

 TABLE -> ADDRESS:
 			ADD_ID (PK)
 			NAME
 			ZIP_CODE (FK)





DESIGN A DATABASE MODEL:

	ORDER
		ORDER_ID(PK)
		ORDER_DATE
		PRODUCT_QUANTITY
		TOTAL_COST
		PRODUCT_ID(FK)
		CUSTOMER_ID(FK)



	CUSTOMER
		CUSTOMER_ID(PK)
		CUSTOMER_NAME
		CUSTOMER_ADDRESS
		CUSTOMER_EMAIL
		CUSTOMER_CONTACT_NUMBER

	DELIVERY
		DELIVERY_ID(PK)
		DELIVERY_ADDRESS
		DELIVERY_STATUS
		COMMENT
		ORDER_ID(FK)


	PRODUCT
		PRODUCT_ID(PK)
		PRODUCT_NAME
		PRODUCT_BUY_PRICE
		PRODUCT_SELL_PRICE
		AMOUNT_IN_STOCK



CREATE VIEW FOR GETTING FULL NAME AND CONTACT NUMBER FROM THE STAFF TABLE UNDER MG_SCHEMA



1)
CREATE VIEW `staff_view` AS 
SELECT FullName AS "Full Name",
ContactNumber AS "Contact Number"
FROM staff;


CREATE TABLE staff(StaffId INT PRIMARY KEY NOT NULL AUTO_INCREMENT,FullName VARCHAR(255),ContactNumber VARCHAR(255),Role VARCHAR(255),Email VARCHAR(255));


INSERT INTO staff (FullName,ContactNumber,Role,Email) VALUES ("Tanvir Rahman","01521534289","Customer","T@gmail.com");
INSERT INTO staff (FullName,ContactNumber,Role,Email) VALUES ("Tonmoy Rahman","01521534281","Admin","To@gmail.com");
INSERT INTO staff (FullName,ContactNumber,Role,Email) VALUES ("Hasib Rahman","01521534282","Manager","Ha@gmail.com");
INSERT INTO staff (FullName,ContactNumber,Role,Email) VALUES ("Dipto Rahman","01521534283","Customer","Di@gmail.com");
INSERT INTO staff (FullName,ContactNumber,Role,Email) VALUES ("Hasnat Rahman","01521534284","Customer","Has@gmail.com");
INSERT INTO staff (FullName,ContactNumber,Role,Email) VALUES ("Tuhin Rahman","01521534285","Customer","Tu@gmail.com");

SELECT * FROM staff;

GET THE DATA FROM VIEW 
SELECT * FROM staff_view;




CLIENT
	CLIENT_ID(PK)         (INT)
	CLIENT_FULL_NAME      (VARCHAR)
	CLIENT_CONTACT_NUMBER (INT)
	CLIENT_EMAIL          (VARCHER)

ORDERS
	ORDER_ID(PK)          (INT)
	ORDER_TOTAL_PRICE     (DECIMAL)
	ORDER_DATE            (DATE)

	CLIENT_ID(FK)         (INT)
	PRODUCT_ID(FK)        (INT)

PRODUCTS
	PRODUCT_ID(PK)        (INT)
	PRODUCT_NAME          (VARCHAR)
	PRODUCT_BUY_PRICE     (DECIMAL)
	PRODUCT_SELL_PRICE    (DECIMAL)
	PRODUCT_AMOUNT_STOCK  (INT)

ADDRESS
	ADDRESS_ID(PK)        (INT)
	ADDRESS_STREET		  (VARCHAR)
	ADDRESS_ZIPCODE       (VARCHAR)
	ADDRESS_STATE         (VARCHAR)

DELIVERY
	DELIVERY_ID(PK)		  (INT)
	DELIVERY_DATE         (DATE)
	DELIVERY_COMMENT      (VARCHAR)

	ORDER_ID(FK)		  (INT)
	ADDRESS_ID(FK)        (INT)






USE MANGATA_AND_GALLO;

INSERT INTO Clients(FullName,ContactNumber,Email)
VALUES 
('Vanessa McCarthy', 757536378, 'vm@mangatagallo.com'), 
('Marcos Romero', 757536379, 'mr@mangatagallo.com'), 
('Hiroki Yamane', 757536376, 'hy@mangatagallo.com'), 
('Anna Iversen', 757536375, 'ai@mangatagallo.com'), 
('Diana Pinto', 757536374, 'dp@mangatagallo.com');

SELECT * FROM Clients;

INSERT INTO Products (ProductName,BuyPrice,SellPrice,AmountInStock)  
VALUES
('Engagement ring', 2000, 2500, 25), 
('Silver brooch', 300, 400, 100), 
('Earrings', 1000, 1250, 100), 
('Luxury watch', 500, 800, 50), 
('Golden bracelet', 800, 1200, 100);

SELECT * FROM Products;


INSERT INTO Address
VALUES 
(1, '223 Golden Hills, North Austin, TX', '78758', 'Texas'),
(2, '119 Silver Street, Bouldin Creek, TX', '78737', 'Texas'), 
(3, '785 Bronze Lane, East Austin, TX', '78717', 'Texas'), 
(4, '908 Diamond Crescent, South Lamar, TX','76643 ', 'Texas'), 
(5, '345, Golden Hills, North Austin, TX', '78759', 'Texas'), 
(6, '812, Diamond Crescent, North Burnet, TX', '78611', 'Texas');

SELECT * FROM Address;

INSERT INTO Orders(OrderDate,ClientID,ProductID,Quantity,TotalPrice) 
VALUES 
('2022-10-15', 1, 1, 1, 2500), 
('2022-10-16', 2, 2, 2, 800), 
('2022-10-17', 3, 5, 1, 800), 
('2022-10-17', 4, 3, 3, 1050), 
('2022-10-18', 5, 4, 1, 1250);

SELECT * FROM Orders;

INSERT INTO Delivery (DeliveryDate,DeliveryStatus,AddressID,Comment,OrderID)
VALUES 
('2022-10-17', 'Done', 1, 'None', 1), 
('2022-10-20', 'Done', 2, 'None', 2), 
('2022-10-22', 'Done', 3, 'None', 3), 
('2022-10-25', 'Done', 4, 'None', 4), 
('2022-10-27', 'Done', 5, 'None', 5);


SELECT * FROM Delivery;



DATA WAREHOUSING:
-----------------------------------

WHAT IS DATA WARE HOUSING:

A DATA WAREHOUSE IS A CENTRALIZD REPOSITORY THAT AGGREGATES, STORES AND PROCESSES LARGE AMOUNT OF DATA FROM MULTIPLE SOURCES.

ITS PURPOSE IS DATA ANALYTICS WORKLOAD NOT TRANSACTIONAL WORKLOAD OF A REGULAR DATABASE MANAGEMENT SYSTEM


REGULAR DATABASE => ONLINE TRANSACTIONAL PROCESSING (OLTP)
DATA WAREHOUSE   => ONLINE ANALYTICAL PROCESSING (OLAP)

DATA WARE HOUSE IS:

1) SUBJECT ORIEDTED
2) INTEGRATED
3) NON VOLATILE
4) TIME VARIANT


1) SUBJECT ORIEDTED: WHEN BUILDING A  DATA WARE HOSUE YOU NEED TO FOCUS ONE OR MORE SUBHJECT AREAS TO EXPLORE. FOR EXAMPLE SALES AND ALL THE RELAVANT INFORMATION OF SALES

2) INTEGRATED: IT INTEGRATED DATA FROM DIFFERENT DATA SOURCCE

3) NON-VOLATILE: DATA SHOULD NOT BE DELETED MUST NOT BE DELETED. REMEMBER THE MORE THE DATA THE ACCURATE THE ANALYSIS OR MODEL.

4) TIME VARIANT: DATA WAREHOUSE MUST AGGRAGATE DATA OVER A LONG PERIOD OF TIME. SO IT CAN MEASURE CHANGES AND TRENDS AND RLATIONSHIP BETTER.



DIFFERENT KINDS OF DATA
1) STRUCTURE DATA (rdbms) DATA WAREHOUSE USES STRUCTURED DATA
2) SEMI STRUCTUREED DATA LIKE eMAIL MESSAGE
3) UN STRUCTURED DATA: DOES NOT HAVE ANY PREDEFINED MODEL; IT REQUIRES MACHINE LEARNING AND DATA MINING
SEMISTRUCTURE DATA AND UNSTRUCTURE DATA ARE ALLED DATA LAKE NOT DATA WAREHOUSE




ARCHITECTURE OF A DATA WAREHOUSE:

THE FIRST COMPONENT OF A DW ARCHITECTURE IS:
	1) DATA SOURCES
		-> EXTERNAL DATA (SOCIAL MEDIA DATA)
		-> INTERNAL DATA (CDATA STORED IN COMPANY DATABASE)
		-> OPERATIONAL DATA (DATA GENERATED FROM THE DAY TODAY ACTIVITY)
		-> FLAT FILE (DATA LOG ENTRY)

	2) DATA STAGING 
		-> EXTRACT
		-> TRANSFORM
		-> LOAD

		FROM THE DATA SOURCE WHICH IS CALLED ETL PROCESS
	
	3) DATA WAREHOUSE :
		AFTER ETL PROCESS FROM THE DATA SOURCES. OR WE CALLED AFTER DATA STAGING DATA IS STORED 
		IN A CENTRAL REPOSITORY WHICH IS CALLED DATA WAREHOUSE. IT ORGANIZED DATA IN RELAITONAL DTABASE.
		IT ALSO HAS META DATA REPO THAT HOLDS THE SOURCE FEATURE AND ATTRIBUTE OF THE DATA

		LIKE WHERE THE DATA ARE CREATED FROM WHO CREATED 

	4) DATA MARTS:  SUBJECT ORIEDTED DATABASE WHICH ACTUALLY IS A SUBSET OF THE DATA WAREHOSUUE DATA FOR A SPECFIC PURPOSE.

	5) WHEN THE DATA IS READY THEN COMES DATA ANALYTICS LIKW DATA ANALYSIS, DATA MINING AND REPORTING

	6) PRESENTATION 
		-> ANALYTICAL REPORTS 
		-> INTERACTIVE REPORTS
		-> STATIC REPORTS



	ETL STANDS FOR EXTRACT, TRANSFORM AND LOAD


To complete the ETL processes you need to:
	
	E => Extract relevant and valid data.  

	T => Transform the extracted data into a suitable format and structure. 

	L => And load the transformed data from various data sources into the data warehouse repository. 

But how can you ensure that the loaded data is correct, valid, reliable, and consistent?   


ETL testing 

The main purpose of ETL testing is to ensure accuracy, reliability, validity and consistency of loaded data. ETL testing investigates whether there are problems in ETL processes that prevent the creation of good quality data. This can be applied by carrying out the following actions: 

	Mapping data in an appropriate way.

	Validating data.

	Checking duplicates of data.

	Validating dates.

	verifying the completeness and correctness of data.




DIMENSIONAL MODEL : 

https://www.youtube.com/watch?v=hQvCOBv_-LE





ER DATA MODEL AND OOP DATA MODEL IS CREATED FOR REAL TIME TRANSACTION.
BUT FOR THE DATA ANALYTICS WE NEED DIMENSIONAL DATA MODEL

A DIMANSIONAL DATA MODEL BASED ON THE CONCEPTS 
	1) DIMANSIONS
	2) FACTS


EXPLAIN EVERYTHING:

FOR EXAMPLE WE ARE MODLING THE A SUPER SHOP SALES DATA .
WE EXPLAIN THIS 
	1) WHAT IS DENORMALIZED DATA
	2) WHAT IS FACTS
	3) WHAT IS DIMENSION
	4) WHAT IS STAR SCHEMA
	5) WHAT IS SNOWFLAKE SCHEMA



1) DENORMALIZED DATA:
	SUPPOSE IN A SALES REPORT IN A SUPERMARKET HAVE THOSE ATTRIBUTES
		
		1) TRANSACTION DATE
		2) ITEM NAME
		3) ITEM_CATEGORY
		4) PRICE_PER_KG
		5) ORDER_WEIGHT
		6) CUSTOMER_NAME
		7) CUSTOMER_EMAIL
		8) CUSTOMER_ADDRESS

YOU CAN SEE ALL THE INFORMATION ARE STORED IN A SINGLE TABLE WHICH IS A HIGHLY DENORMALIZED DATABASE
EVERYTHING IN STORED IN A SINGLE ROW. IN ORDER TO MAKE A NORMALIZED DATABASE WE SEPARATE THE REDUNDANT INFORMATION . FOR EXAMPLE THE CUSTOMER INFORMATION SHOULD GO UNDER CUSTOMER TABLE.OTHERWISE THERE WILL BE REDUNDANT AND DUPLICATION O DATA

SO LETS SEPARATE THE DATA:
		1) TRANSACTIO_ID
	    2) TRANSACTION DATE
		3) ITEM NAME
		4) ITEM_CATEGORY
		5) PRICE_PER_KG
		6) ORDER_WEIGHT
		


STORE SPECFIC INFORMATION

		CUSTOMER TABLE:                               
			1) CUSTOMER_ID
			2) CUSTOMER_NAME
			3) CUSTOMER_EMAIL
			4) CUSTOMER_ADDRESS

AND WE ADD THE CUSTOMER_ID TO THE MAIN TABLE AS A FOREIGN KEY
NOW THE MAIN (TRANSCACTION TABLE) TABLE IS 

	1) TRANSACTION_ID
	2) CUSTOMER_ID (PK)
	3) TRANSACTION_DATE
	4) ITEM_NAME
	5) ITEM_CATEGORY
	6) PRICE_PER_KG
	7) ORDER_WEIGHT


LETS DENORMALIZE IT FURTHER

	ITEM TABLE:
		1) ITEM_ID
		2) ITEM_NAME
		3) ITEM_CATEGORY
		4) PRICE_PER_KG

	NOW OUR TRANSACTION TABLE (MAIN TABLE/PARENT TABLE/FACT TABLE):

		1) TRANSACTION_ID
		2) CUSTOMER_ID (PK)
		3) TRANSACTION_DATE
		4) ITEM_ID(PK)
		5) ORDER_WEIGHT






SO THE TOTAL DATABASE DESIGN WIL BE FOLLOW:

	FACT TABLE:
		TRANSACTION:
			1) TRANSACTION_ID
			2) CUSTOMER_ID (PK)
			3) TRANSACTION_DATE
			4) ITEM_ID(PK)
			5) ORDER_WEIGHT

	DIMENSION TABLE:
		CUSTOMER:                               
			1) CUSTOMER_ID
			2) CUSTOMER_NAME
			3) CUSTOMER_EMAIL
			4) CUSTOMER_ADDRESS

		ITEM TABLE:
			1) ITEM_ID
			2) ITEM_NAME
			3) ITEM_CATEGORY
			4) PRICE_PER_KG







		IN THIS EXAMPLE WHICH ONE IS THE FACT TABLE:

			ANS : THE TRANSACTION TABLE (BECAUSE THIS IS THE PARENT TABLE)

		IN THIS EXAMPE WHICH ONE IS THE  DIMENSION TABLE:
			ANS : THE ITEM TABLE,CUSTOMER TABLE THIS ARE THE DIMENSION TABLE BECAUSE THEY ARE STORING AN
				  EXTRA INFORMATION.

SO SALES/TRNASACTION TABLE IN THE MIDDLE AND THE CUSTOMER AND ITEM TABLE ARE THE BRANCH 
SO SALES TABLE IS THE FACT TABLE
ITEM AND CUSTOMER TABLE ARE THE DIMENSION TABLE BECAUSE THEY HOLD ADDITIONAL INFORMATION 

THIS IS CALLED STAR SCHEMA.


SO WHAT IS SNOWFLAKE SCHEMA:


IF YOU LOOK CAREFULLY YOU CAN SEE IN STAR SCHEMA IN THE MIDDLE THERE IS FACT TABLE
AND IN THE AROUND THAT THERE IS DIMENSION TABLE . BUT THE DIMENSION TABLE IS NOT GET MORE
BRANCH. IN THE STAR SCHEMA THER EIS 1 DEGREE BRANCHING. 

IF THE DIMENSION TABLE WILL BE BRANCHED FURTHER LIKE BELLOW:
LIKE WE CAN DIVIDE THE ITEM TABLE LIKE THAT

	ITEM TABLE:
     		1) ITEM_ID
			2) ITEM_NAME
			3) CATEGORY_ID
			4) PRICE_PER_KG


	CATEGORY TABLE:
			1) CATEGORY_ID
			2) CATEGORY_NAME


SO THE DIMENSION TABLE ITEM IS BRANCHED AGAIN .


THIS IS CALLED SNOWFLAKE SCHEMA.



THERE ARE FOUR STEPS TO MAKE A DIMENSIONAL DATA MODEL:

1) THE BUSINESS PROCESS (IDENTIFY A BUSINESS ACTIVITY) 
2) THE GRAINS (WHAT LEVEL OF GRANULARITY IS NEEDED)
3) THE DIMENSION  (WHAT ADDITIONAL CONTEXT DO YOU NEED TO ANALYZE THE DATA)
4) THE FACTS (WHAT DO YOU WANT TO MEAUSRE) 



CREATE A SALES DATABASE (START SCHEMA):

    [FACT]
	SALES ABLE :
		SALES_ID(PK)		(INT)
		CUSTOMER_ID(FK)		(INT)
		PRODUCT_ID(FK)		(INT)
		LOCATION_ID(FK)		(INT)
		TIME_ID(FK)			(INT)
		QUANTITY 			(INT)
		TOTAL_COST 		    (DECIMAL)
		TOTAL_PRICE 	    (DECIMAL)

	[DIMENSION]:
	CUSTOMER
		CUSTOMER_ID(PK)		(INT)
		CUSTOMER_NAME       (VARCHAR)
		CUSTOMER_ADDRESS	(VARCHAR)
		CUSTOMER_AGE		(INT)
		CUSTOMER_GENDER		(VARCHAR)
		CUSTOMER_INCOME		(DECIMAL)

	PRODUCT
		PRODUCT_ID(PK)		(INT)
		PRODUCT_NAME		(VARCHAR)
		CATEGORY 			(VARCHAR)
		SUBCATEGORY			(VARCHAR)


	LOCATION
		LOCATION_ID(PK)		(INT)
		LOCATION_NAME		(VARCHAR)
		COUNTRY				(VARCHAR)
		CITY 				(VARHCAR)

	TIME
		TIME_ID(PK)			(INT)
		FULL_DATE			(DATETIME)
		YEAR  				(INT)
		QUARTER				(INT)
		MONTH				(INT)





NOW IF WE WANT TO DO A SNOWFLAKE SCHEMA  WE CAN BREAK THE TABLE PRODUCT IN 2 LEVEL


SNOWFLAKE SCHEMA:

	    [FACT]
	SALES ABLE :
		SALES_ID(PK)		(INT)
		CUSTOMER_ID(FK)		(INT)
		PRODUCT_ID(FK)		(INT)
		LOCATION_ID(FK)		(INT)
		TIME_ID(FK)			(INT)
		QUANTITY 			(INT)
		TOTAL_COST 		    (DECIMAL)
		TOTAL_PRICE 	    (DECIMAL)

	[DIMENSION]:
	CUSTOMER
		CUSTOMER_ID(PK)		(INT)
		CUSTOMER_NAME       (VARCHAR)
		CUSTOMER_ADDRESS	(VARCHAR)
		CUSTOMER_AGE		(INT)
		CUSTOMER_GENDER		(VARCHAR)
		CUSTOMER_INCOME		(DECIMAL)

	PRODUCT
		PRODUCT_ID(PK)		(INT)
		PRODUCT_NAME		(VARCHAR)
		CATEGORY_ID(FK)		(INT)
		

	CATEGORY:
		CATEGORY_ID(PK)		(INT)
		CATEGORY_NAME		(VARHCAR)
		SUBCATEGORY_ID(FK)	(INT)

	SUNCATEGORY:
		SUBCATEGORY_ID(PK)	(INT)
		SUBCATEGORY_NAME	(VARCHAR)


	LOCATION
		LOCATION_ID(PK)		(INT)
		LOCATION_NAME		(VARCHAR)
		COUNTRY				(VARCHAR)
		CITY 				(VARHCAR)

	TIME
		TIME_ID(PK)			(INT)
		FULL_DATE			(DATETIME)
		YEAR  				(INT)
		QUARTER				(INT)
		MONTH				(INT)





